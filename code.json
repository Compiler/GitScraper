{"allcode" :
    {"code": 
        {"body": "public Matrix(int n, int m, Boolean random){\n    matrix = new double[n][m];\n    if(random){\n      Random r = new Random();\n      for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n          matrix[i][j] = 2*r.nextDouble()-1;\n        }\n      }\n    }\n  }",
        "comment": "/**\n * Constructs matrix of doubles with values 0.0 or random values between 1 and -1\n * @param  n Number of rows the Matrix has.\n * @param  m Number of columns the Matrix has.\n * @param  random Determines weather the matrix is to be populated with random\n * doubles from 1 to -1.\n * @since 1.0\n */"
    }},
{"code": {"body": "public Matrix(int n, int m){\n    matrix = new double[n][m];\n  }", "comment": "/**\n * Constructs matrix of doubles with values 0.0\n * @param  n Number of rows the Matrix has.\n * @param  m Number of columns the Matrix has.\n * doubles from 1 to -1.\n * @since 1.0\n */"}},
{"code": {"body": "public Matrix(double[][] matrix){\n    float length = matrix[0].length;\n    for(int i=1; i<matrix.length; i++){\n      if(matrix[i].length != length){\n        throw new MatrixException(\"Matrix has to be \\\"rectangular\\\".}\");\n      }\n    }", "comment": "/**\n * Constructs matrix with structure of double array.\n * @param  matrix A double array representaion of the Matrix.\n * @throws MatrixException Throws MatrixException is the input array is not rectangular\n * @since 1.0\n */"}},
{"code": {"body": "  public double[][] getMatrixAsArray(){\n    return matrix;\n  }", "comment": "/**\n * Returns the Matrix as a double array.\n * @return Matrix as a double array.\n * @since 1.0\n */"}},
{"code": {"body": "  public double get(int n, int m){\n    return matrix[n][m];\n  }", "comment": "/**\n * Gets any element of the Matrix\n * @param  n The row in which the element is.\n * @param  m The column in which the element is.\n * @return The element at location (n, m).\n * @since 1.0\n */"}},
{"code": {"body": "  public void set(int n, int m, double x){\n    matrix[n][m] = x;\n  }", "comment": "/**\n * Sets the value of a given element\n * @param  n The row of the emement in which you want to change.\n * @param  m The column of the element in which you want to change.\n * @since 1.0\n */"}},
{"code": {"body": "  public int[] getSize(){\n    int[] size = {matrix.length, matrix[0].length};\n    return size;\n  }", "comment": "/**\n * Returns the size of the matrix as an array of int.\n * @return Size of the matrix as an array of ints.\n * @since 1.0\n */"}},
{"code": {"body": "  public String toString(){\n    String matrixString = Arrays.deepToString(matrix).replaceAll(\"\\\\Q], [\\\\E\", \"]\\n[\");\n    return matrixString.substring(1, matrixString.length()-1);\n  }", "comment": "/**\n  * Converts the Matrix into String form.\n  * @return The Matrix in String from.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix add(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[0] != y.getSize()[0] || x.getSize()[1] != y.getSize()[1]) {throw new MatrixException(\"Dimentions for add do not match\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<x.getSize()[1]; j++){\n          newMatrix.set(i,j,(x.get(i,j)+y.get(i,j)));\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix addition on two matricies.\n  * @param  x Matrix you want to add.\n  * @param  y Matrix you want to add.\n  * @return The sum of the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont match.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix sub(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[0] != y.getSize()[0] || x.getSize()[1] != y.getSize()[1]) {throw new MatrixException(\"Dimentions for sub do not match\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<x.getSize()[1]; j++){\n          newMatrix.set(i,j,(x.get(i,j)-y.get(i,j)));\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix subtraction on two matricies.\n  * @param  x Matrix you want to subtract.\n  * @param  y Matrix you want to subtract.\n  * @return The differnce between the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont match.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix mult(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[1] != y.getSize()[0]) {throw new MatrixException(\"Dimentions for mult do not match: (\"+x.getSize()[0]+\", \"+x.getSize()[1]+\"), (\"+y.getSize()[0]+\", \"+y.getSize()[1]+\")\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], y.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<y.getSize()[1]; j++){\n          double cell = 0;\n          for(int k=0; k<x.getSize()[1]; k++){\n            cell += x.get(i, k)*y.get(k, j);\n          }\n          newMatrix.set(i ,j ,cell);\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix multiplication on two matricies.\n  * @param  x Matrix you want to multiply.\n  * @param  y Matrix you want to multiply.\n  * @return The product of the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont allow matrix multiplication.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix scalarMult(Matrix x, double y){\n    Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n    for(int i=0; i<x.getSize()[0]; i++){\n      for(int j=0; j<x.getSize()[1]; j++){\n        newMatrix.set(i, j, x.get(i, j)*y);\n      }\n    }\n    return newMatrix;\n  }", "comment": "/**\n  * Returns the result of multipling a matrix my a scalar value.\n  * @param  x Matrix you want to multiply.\n  * @param  y The scarlar value you want to multiply the matrix by.\n  * @return The new  of the two matricies x and y.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix make3DRotationMatrix(double radians, char axis){\n    double sinTheta = Math.sin(radians);\n    double cosTheta = Math.cos(radians);\n    switch(axis){\n      case 'x':\n      case 'X': return new Matrix(new double[][]{{1, 0, 0},\n                                                 {0, cosTheta, -sinTheta},\n                                                 {0, sinTheta, cosTheta}});\n      case 'y':\n      case 'Y': return new Matrix(new double[][]{{cosTheta, 0, sinTheta},\n                                                 {0, 1, 0},\n                                                 {-sinTheta, 0, cosTheta}});\n      case 'z':\n      case 'Z': return new Matrix(new double[][]{{cosTheta, -sinTheta, 0},\n                                                 {sinTheta, cosTheta, 0},\n                                                 {0, 0, 1}});\n      default: return null;\n    }\n  }", "comment": "/**\n  * Returns the transformation Matrix to perfrom a 3d rotation about the origin.\n  * @param  radians The number of radians you want to rotate by.\n  * @param  axis The axis ('x', 'y' or 'z') you want to rotate about.\n  * @return The transformation Matrix corresponding to the parameters.\n  * @since 1.0\n  */"}},
{"code": {"body": "public Camera(){\n    location = new Point(0, 0, 0);\n    pitch = 0; yaw = 0; }", "comment": "/**\n  * Creates a Camera with location (0, 0, 0) facing along the z axis\n  * @since 1.0\n  */"}},
{"code": {"body": "public Camera(Point location){\n    this.location = location;\n    pitch = 0; yaw = 0; }", "comment": "/**\n * Creates a Camera with a specific location facing along the z axis\n * @param  location The location for the Camera to be initialsed at.\n * @since 1.0\n */"}},
{"code": {"body": "public Camera(Point location, double pitch, double yaw){\n    this.location = new Point(0, 0, 0);\n    this.pitch = pitch; this.yaw = yaw; }", "comment": "/**\n * Creates a Camera with a specific location facing a specific direction.\n * @param  location The location for the Camera to be initialsed at.\n * @param  pitch The angle the Camera is facing up from the xz plane.\n * @param  yaw The angle the Camera is facing right from the yz plane.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveRelative(double x, double y, double z){\n    location.setX(location.getX()+x);\n    location.setY(location.getY()+y);\n    location.setZ(location.getZ()+z);\n  }", "comment": "/**\n * Moves the camera by an offset from the current location.\n * @param  x The size of the offset in the x direction.\n * @param  y The size of the offset in the y direction.\n * @param  z The size of the offset in the z direction.\n * @since 1.0\n */"}},
{"code": {"body": "  public void setLocation(Point location){\n    this.location = location;\n  }", "comment": "/**\n * Sets the Camera location.\n * @param  location The point you want to move the camera to.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveFawardByDisplacment(double x){\n    location.setX(location.getX()+x*Math.cos(pitch)*Math.sin(yaw));\n    location.setY(location.getY()+x*Math.sin(pitch));\n    location.setZ(location.getZ()+x*Math.cos(pitch)*Math.cos(yaw));\n  }", "comment": "/**\n * Moves the Camera by a distance in the direction the camera is facing.\n * @param  x The displacment you want to move the camera by.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveRightByDisplacment(double x){\n    double piOver2 = Math.PI/2;\n    location.setX(location.getX()+x*Math.cos(pitch)*Math.sin(yaw+piOver2));\n\n    location.setZ(location.getZ()+x*Math.cos(pitch)*Math.cos(yaw+piOver2));\n  }", "comment": "/**\n * Moves the Camera by a distance in the direction perpendicular to both direction the camera is facing and the y axis.\n * @param  x The displacment you want to move the camera by.\n * @since 1.0\n */"}},
{"code": {"body": "  public Point getLocation(){\n    return location;\n  }", "comment": "/**\n * Gets the Camera Location.\n * @return The Location of the Camera.\n * @since 1.0\n */"}},
{"code": {"body": "  public void changeAngleRelative(double x, double y){\n    pitch += x;\n    yaw += y;\n  }", "comment": "/**\n  * Changes the direction that the camera is facing by specific angles.\n  * @param  x The anlge you want to turn around the x axis.\n  * @param  y The anlge you want to turn around the y axis.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public void setPitch(double x){\n    pitch = x;\n  }", "comment": "/**\n  * Sets the pitch (angle up from xz plane) angle.\n  * @param  x The anlge you want to set the pitch (angle up from xz plane) as.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public void setYaw(double x){\n    yaw = x;\n  }", "comment": "/**\n  * Sets the yaw (angle right from yz plane) angle.\n  * @param  x The anlge you want to set the pitch (angle right from yz plane) as.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public double getPitch(){\n    return pitch;\n  }", "comment": "/**\n * Gets the Camera pitch (angle up from xz plane).\n * @return The pitch (angle up from xz plane).\n * @since 1.0\n */"}},
{"code": {"body": "  public double getYaw(){\n    return yaw;\n  }", "comment": "/**\n * Gets the Camera yaw (angle right from yz plane).\n * @return The pitch (angle up from xz plane).\n * @since 1.0\n */"}},
}{"code": {"body": "public Matrix(int n, int m, Boolean random){\n    matrix = new double[n][m];\n    if(random){\n      Random r = new Random();\n      for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n          matrix[i][j] = 2*r.nextDouble()-1;\n        }\n      }\n    }\n  }", "comment": "/**\n * Constructs matrix of doubles with values 0.0 or random values between 1 and -1\n * @param  n Number of rows the Matrix has.\n * @param  m Number of columns the Matrix has.\n * @param  random Determines weather the matrix is to be populated with random\n * doubles from 1 to -1.\n * @since 1.0\n */"}},
{"code": {"body": "public Matrix(int n, int m){\n    matrix = new double[n][m];\n  }", "comment": "/**\n * Constructs matrix of doubles with values 0.0\n * @param  n Number of rows the Matrix has.\n * @param  m Number of columns the Matrix has.\n * doubles from 1 to -1.\n * @since 1.0\n */"}},
{"code": {"body": "public Matrix(double[][] matrix){\n    float length = matrix[0].length;\n    for(int i=1; i<matrix.length; i++){\n      if(matrix[i].length != length){\n        throw new MatrixException(\"Matrix has to be \\\"rectangular\\\".}\");\n      }\n    }", "comment": "/**\n * Constructs matrix with structure of double array.\n * @param  matrix A double array representaion of the Matrix.\n * @throws MatrixException Throws MatrixException is the input array is not rectangular\n * @since 1.0\n */"}},
{"code": {"body": "  public double[][] getMatrixAsArray(){\n    return matrix;\n  }", "comment": "/**\n * Returns the Matrix as a double array.\n * @return Matrix as a double array.\n * @since 1.0\n */"}},
{"code": {"body": "  public double get(int n, int m){\n    return matrix[n][m];\n  }", "comment": "/**\n * Gets any element of the Matrix\n * @param  n The row in which the element is.\n * @param  m The column in which the element is.\n * @return The element at location (n, m).\n * @since 1.0\n */"}},
{"code": {"body": "  public void set(int n, int m, double x){\n    matrix[n][m] = x;\n  }", "comment": "/**\n * Sets the value of a given element\n * @param  n The row of the emement in which you want to change.\n * @param  m The column of the element in which you want to change.\n * @since 1.0\n */"}},
{"code": {"body": "  public int[] getSize(){\n    int[] size = {matrix.length, matrix[0].length};\n    return size;\n  }", "comment": "/**\n * Returns the size of the matrix as an array of int.\n * @return Size of the matrix as an array of ints.\n * @since 1.0\n */"}},
{"code": {"body": "  public String toString(){\n    String matrixString = Arrays.deepToString(matrix).replaceAll(\"\\\\Q], [\\\\E\", \"]\\n[\");\n    return matrixString.substring(1, matrixString.length()-1);\n  }", "comment": "/**\n  * Converts the Matrix into String form.\n  * @return The Matrix in String from.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix add(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[0] != y.getSize()[0] || x.getSize()[1] != y.getSize()[1]) {throw new MatrixException(\"Dimentions for add do not match\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<x.getSize()[1]; j++){\n          newMatrix.set(i,j,(x.get(i,j)+y.get(i,j)));\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix addition on two matricies.\n  * @param  x Matrix you want to add.\n  * @param  y Matrix you want to add.\n  * @return The sum of the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont match.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix sub(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[0] != y.getSize()[0] || x.getSize()[1] != y.getSize()[1]) {throw new MatrixException(\"Dimentions for sub do not match\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<x.getSize()[1]; j++){\n          newMatrix.set(i,j,(x.get(i,j)-y.get(i,j)));\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix subtraction on two matricies.\n  * @param  x Matrix you want to subtract.\n  * @param  y Matrix you want to subtract.\n  * @return The differnce between the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont match.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix mult(Matrix x, Matrix y) throws MatrixException{\n    if(x.getSize()[1] != y.getSize()[0]) {throw new MatrixException(\"Dimentions for mult do not match: (\"+x.getSize()[0]+\", \"+x.getSize()[1]+\"), (\"+y.getSize()[0]+\", \"+y.getSize()[1]+\")\");}\n    else{\n      Matrix newMatrix = new Matrix(x.getSize()[0], y.getSize()[1]);\n      for(int i=0; i<x.getSize()[0]; i++){\n        for(int j=0; j<y.getSize()[1]; j++){\n          double cell = 0;\n          for(int k=0; k<x.getSize()[1]; k++){\n            cell += x.get(i, k)*y.get(k, j);\n          }\n          newMatrix.set(i ,j ,cell);\n        }\n      }\n      return newMatrix;\n    }\n  }", "comment": "/**\n  * Returns the result of performing matrix multiplication on two matricies.\n  * @param  x Matrix you want to multiply.\n  * @param  y Matrix you want to multiply.\n  * @return The product of the two matricies x and y.\n  * @throws MatrixException Throws MatrixException if the dimentions of the two\n  * matricies dont allow matrix multiplication.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix scalarMult(Matrix x, double y){\n    Matrix newMatrix = new Matrix(x.getSize()[0], x.getSize()[1]);\n    for(int i=0; i<x.getSize()[0]; i++){\n      for(int j=0; j<x.getSize()[1]; j++){\n        newMatrix.set(i, j, x.get(i, j)*y);\n      }\n    }\n    return newMatrix;\n  }", "comment": "/**\n  * Returns the result of multipling a matrix my a scalar value.\n  * @param  x Matrix you want to multiply.\n  * @param  y The scarlar value you want to multiply the matrix by.\n  * @return The new  of the two matricies x and y.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public static Matrix make3DRotationMatrix(double radians, char axis){\n    double sinTheta = Math.sin(radians);\n    double cosTheta = Math.cos(radians);\n    switch(axis){\n      case 'x':\n      case 'X': return new Matrix(new double[][]{{1, 0, 0},\n                                                 {0, cosTheta, -sinTheta},\n                                                 {0, sinTheta, cosTheta}});\n      case 'y':\n      case 'Y': return new Matrix(new double[][]{{cosTheta, 0, sinTheta},\n                                                 {0, 1, 0},\n                                                 {-sinTheta, 0, cosTheta}});\n      case 'z':\n      case 'Z': return new Matrix(new double[][]{{cosTheta, -sinTheta, 0},\n                                                 {sinTheta, cosTheta, 0},\n                                                 {0, 0, 1}});\n      default: return null;\n    }\n  }", "comment": "/**\n  * Returns the transformation Matrix to perfrom a 3d rotation about the origin.\n  * @param  radians The number of radians you want to rotate by.\n  * @param  axis The axis ('x', 'y' or 'z') you want to rotate about.\n  * @return The transformation Matrix corresponding to the parameters.\n  * @since 1.0\n  */"}},
{"code": {"body": "public Camera(){\n    location = new Point(0, 0, 0);\n    pitch = 0; yaw = 0; }", "comment": "/**\n  * Creates a Camera with location (0, 0, 0) facing along the z axis\n  * @since 1.0\n  */"}},
{"code": {"body": "public Camera(Point location){\n    this.location = location;\n    pitch = 0; yaw = 0; }", "comment": "/**\n * Creates a Camera with a specific location facing along the z axis\n * @param  location The location for the Camera to be initialsed at.\n * @since 1.0\n */"}},
{"code": {"body": "public Camera(Point location, double pitch, double yaw){\n    this.location = new Point(0, 0, 0);\n    this.pitch = pitch; this.yaw = yaw; }", "comment": "/**\n * Creates a Camera with a specific location facing a specific direction.\n * @param  location The location for the Camera to be initialsed at.\n * @param  pitch The angle the Camera is facing up from the xz plane.\n * @param  yaw The angle the Camera is facing right from the yz plane.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveRelative(double x, double y, double z){\n    location.setX(location.getX()+x);\n    location.setY(location.getY()+y);\n    location.setZ(location.getZ()+z);\n  }", "comment": "/**\n * Moves the camera by an offset from the current location.\n * @param  x The size of the offset in the x direction.\n * @param  y The size of the offset in the y direction.\n * @param  z The size of the offset in the z direction.\n * @since 1.0\n */"}},
{"code": {"body": "  public void setLocation(Point location){\n    this.location = location;\n  }", "comment": "/**\n * Sets the Camera location.\n * @param  location The point you want to move the camera to.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveFawardByDisplacment(double x){\n    location.setX(location.getX()+x*Math.cos(pitch)*Math.sin(yaw));\n    location.setY(location.getY()+x*Math.sin(pitch));\n    location.setZ(location.getZ()+x*Math.cos(pitch)*Math.cos(yaw));\n  }", "comment": "/**\n * Moves the Camera by a distance in the direction the camera is facing.\n * @param  x The displacment you want to move the camera by.\n * @since 1.0\n */"}},
{"code": {"body": "  public void moveRightByDisplacment(double x){\n    double piOver2 = Math.PI/2;\n    location.setX(location.getX()+x*Math.cos(pitch)*Math.sin(yaw+piOver2));\n\n    location.setZ(location.getZ()+x*Math.cos(pitch)*Math.cos(yaw+piOver2));\n  }", "comment": "/**\n * Moves the Camera by a distance in the direction perpendicular to both direction the camera is facing and the y axis.\n * @param  x The displacment you want to move the camera by.\n * @since 1.0\n */"}},
{"code": {"body": "  public Point getLocation(){\n    return location;\n  }", "comment": "/**\n * Gets the Camera Location.\n * @return The Location of the Camera.\n * @since 1.0\n */"}},
{"code": {"body": "  public void changeAngleRelative(double x, double y){\n    pitch += x;\n    yaw += y;\n  }", "comment": "/**\n  * Changes the direction that the camera is facing by specific angles.\n  * @param  x The anlge you want to turn around the x axis.\n  * @param  y The anlge you want to turn around the y axis.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public void setPitch(double x){\n    pitch = x;\n  }", "comment": "/**\n  * Sets the pitch (angle up from xz plane) angle.\n  * @param  x The anlge you want to set the pitch (angle up from xz plane) as.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public void setYaw(double x){\n    yaw = x;\n  }", "comment": "/**\n  * Sets the yaw (angle right from yz plane) angle.\n  * @param  x The anlge you want to set the pitch (angle right from yz plane) as.\n  * @since 1.0\n  */"}},
{"code": {"body": "  public double getPitch(){\n    return pitch;\n  }", "comment": "/**\n * Gets the Camera pitch (angle up from xz plane).\n * @return The pitch (angle up from xz plane).\n * @since 1.0\n */"}},
{"code": {"body": "  public double getYaw(){\n    return yaw;\n  }", "comment": "/**\n * Gets the Camera yaw (angle right from yz plane).\n * @return The pitch (angle up from xz plane).\n * @since 1.0\n */"}},
